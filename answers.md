>1. Какой самый эффективный способ конкатенации строк?

До Go 1.10 приходилось использовать bytes.Buffer и его метод WriteString

В Go 1.10+ есть strings.Builder c методом WriteString

>2. Что такое интерфейсы, как они применяются в Go?

Интерфейсы по сути являются способом обозначения множества допустимых для нашей переменной типов.

Они позволяют установить ограничения как и на сам нижележащий тип (если использовать типовые параметры), так и на то, какие методы тип должен имплементить.

Их используют как замену полиморфизма из ооп.

>3. Чем отличаются RWMutex от Mutex?

У RWMutex разные методы Lock и Unlock для целей записи и чтения, потому что он позволяет иметь Lock неограниченному количеству читателей в один момент (но без писателей) и только лишь одному писателю в один момент.

Mutex не позволяет иметь Lock более чем одному владельцу в один момент.

>4. Чем отличаются буферизированные и не буферизированные каналы?

У буферизированных каналов есть буфер, который позволяет, например, писать в канал без блокировки без ожидания чтения из него на другой стороне (конечно же до момента заполнения буфера, тогда запись снова будет блокирующей).

Тоже самое с чтением - пока буфер не пуст, чтение не будет блокировать исполнение до записи с другой стороны.

>5. Какой размер у структуры struct{}{}?

Она имеет размер 0.

Казалось бы, как адресуемая величина может иметь размер 0? 

Тут прикол в том, что компилятор даёт всем таким значениям один и тот же адрес, что позволяет нам их адресовать, но не выделять на них память.

>6. Есть ли в Go перегрузка методов или операторов?

[Нет](https://go.dev/doc/faq#overloading)

>7. В какой последовательности будут выведены элементы map[int]int?
>
>Пример:
``` go
m[0]=1
m[1]=124
m[2]=281
```

По крайней мере при использовании форматного флага %v, они выводятся в порядке ключей, то есть

0: 1, 1: 124, 2: 281

[proof](https://go.dev/play/p/8A-63XtwIWs)

>8. В чем разница make и new?

make работает только на слайсах, мапах и каналах, а также позволяет использовать некоторые параметры при их инициализации.

new выделяет память для пемеренной и возвращает указатель на неё и работает на любых типах, но не инициализирует саму переменную.

>9. Сколько существует способов задать переменную типа slice или map?

Обычно из задают с помощью функции make, но также можно задавать их следующим способом ([composite literal](https://go.dev/ref/spec#Composite_literals)):
```
v := map[int]int{}
s := []int{}
```

>10. Что выведет данная программа и почему?
``` go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```

Поскольку в функции update мы меняем значение самого указателя, а не нижележащей переменной, её значение останется тем же самым.

Поэтому будет выведено две цифры 1.

>11. Что выведет данная программа и почему?

``` go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```

Будут выведены цифры от 0 до 4 включительно (а также exit в конце выполнения), но их порядок предсказать заранее невозможно, поскольку они будут выводиться конкурентно.

>12. Что выведет данная программа и почему?

``` go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```

Данная программа выведет 0, потому что в блоке if мы затмеваем внешнее объявление n.

>13. Что выведет данная программа и почему?

``` go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
} 
```

Данная программа выведет [100, 2, 3, 4, 5], поскольку в функции someAction мы не возвращаем новый слайс с добавленным элементом, а присваиваем его локальной переменной.

>14. Что выведет данная программа и почему?

``` go
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}  
```

Данная программа выведет сначала ["b", "b", "a"], затем ["a", "a"], поскольку вызывая append мы создаём локальную копию изначального слайса с новым элементом.








